var documenterSearchIndex = {"docs":
[{"location":"freqdepsqz/#Calculating-the-Hamiltonian-for-frequency-dependent-squeezing","page":"Calculating the Hamiltonian for frequency-dependent squeezing","title":"Calculating the Hamiltonian for frequency-dependent squeezing","text":"","category":"section"},{"location":"freqdepsqz/","page":"Calculating the Hamiltonian for frequency-dependent squeezing","title":"Calculating the Hamiltonian for frequency-dependent squeezing","text":"using SystemLevelHamiltonian\n\nfilter_cav = cavity(:filter)\nsqz_cav = squeezing_cavity(:sqz)\nifo = radiation_pressure_cavity(:ifo)\n\nsys = concatenate(:feqdepsqz,[sqz_cav,filter_cav,ifo])\nsys = feedbackreduce(sys,:Output_sqz,:Input_filter)\nsys = feedbackreduce(sys,:Output_filter,:Input_ifo)","category":"page"},{"location":"freqdepsqz/","page":"Calculating the Hamiltonian for frequency-dependent squeezing","title":"Calculating the Hamiltonian for frequency-dependent squeezing","text":"sys.H","category":"page"},{"location":"freqdepsqz/","page":"Calculating the Hamiltonian for frequency-dependent squeezing","title":"Calculating the Hamiltonian for frequency-dependent squeezing","text":"operators(sys)","category":"page"},{"location":"freqdepsqz/","page":"Calculating the Hamiltonian for frequency-dependent squeezing","title":"Calculating the Hamiltonian for frequency-dependent squeezing","text":"parameters(sys)","category":"page"},{"location":"api/#SLH-systems","page":"API","title":"SLH systems","text":"","category":"section"},{"location":"api/#SystemLevelHamiltonian.SLH","page":"API","title":"SystemLevelHamiltonian.SLH","text":"SLH(name, inputs, outputs, S, L, H)\n\nAn SLH triple describes an open quantum system. See Combes, arXiv.1611.00375\n\nThe name of the system should be unique. When multiple systems are combined, the names of their inputs and outputs will  have the system name appended to them. The inputs and outputs describe 'ports' where signals leave and enter the system. Quantum systems must have the same number of inputs and outputs, which we denote by n.\n\nsize(S) = (n, n) <- S is an nxn matrix size(L) = (n,) size(H) = ()\n\nThe two ways of combining SLH systems are concatenate() and feedbackreduce()\n\n\n\n\n\n","category":"type"},{"location":"api/#SystemLevelHamiltonian.concatenate","page":"API","title":"SystemLevelHamiltonian.concatenate","text":"concatenate(name, syslist::Vector{SLH})\n\ncreates a composite system with no interconnections. Combes eq. 59\n\n\n\n\n\n","category":"function"},{"location":"api/#SystemLevelHamiltonian.feedbackreduce","page":"API","title":"SystemLevelHamiltonian.feedbackreduce","text":"feedbackreduce(A::SLH,output,input)\n\nConnects the output port to the input port, reducing the number of outputs and inputs by one each. Combes eq 61.\n\n\n\n\n\n","category":"function"},{"location":"api/#SystemLevelHamiltonian.operators","page":"API","title":"SystemLevelHamiltonian.operators","text":"operators(sys)\n\nreturns all the quantum operators contained in the system's Hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"api/#SystemLevelHamiltonian.parameters","page":"API","title":"SystemLevelHamiltonian.parameters","text":"parameters(sys)\n\nreturns all the symbolic numbers contained in the system's Hamiltonian and coupling vector L.\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantum-information","page":"API","title":"Quantum information","text":"","category":"section"},{"location":"api/#SystemLevelHamiltonian.sld_operator","page":"API","title":"SystemLevelHamiltonian.sld_operator","text":"sld_operator(rho::AbstractMatrix, drho::AbstractMatrix; tol=1e-12)\n\nCompute the symmetric logarithmic derivative (SLD) L for a given density matrix rho and its parameter derivative drho, using the eigenbasis method. Returns L in the original basis.\n\nArguments\n\nrho: Hermitian density matrix (N×N)\ndrho: Derivative of the density matrix with respect to some parameter\ntol: Threshold for eigenvalues considered nonzero (default: 1e-5)\n\nReturns\n\nL: Symmetric logarithmic derivative (N×N Hermitian matrix)\n\n\n\n\n\n","category":"function"},{"location":"api/#SystemLevelHamiltonian.compute_qfi","page":"API","title":"SystemLevelHamiltonian.compute_qfi","text":"compute_qfi(sys,Ncutoff, T, params, param, backend)\n\nComputes the quantum Fisher information of the final state of the system after evolving for time T, with respect to the parameter 'param.' The nominal values of all parameters must be provided as a dictionary mapping parameters to values in 'params.' The differentiation required to calculate the symmetric logarithmic derivative is carried out by DifferentiationInterface, so an autodiff backend is passed as 'backend.' For now use AutoFiniteDiff(). \n\n\n\n\n\n","category":"function"},{"location":"jcfisher/#Calculating-the-QFI-of-a-Jaynes-Cummings-model","page":"Calculating the QFI of a Jaynes-Cummings model","title":"Calculating the QFI of a Jaynes-Cummings model","text":"","category":"section"},{"location":"jcfisher/","page":"Calculating the QFI of a Jaynes-Cummings model","title":"Calculating the QFI of a Jaynes-Cummings model","text":"\nusing SystemLevelHamiltonian\nusing QuantumCumulants\nusing DifferentiationInterface\n\n##############################################################\n### SYSTEM DEFINITION\n\n# Define parameters and their numerical values\nps = @cnumbers Δ g κ h \n\n# Define hilbert space\nhf = FockSpace(:cavity)\nha = NLevelSpace(:atom,(:g,:e))\nhilb = QuantumCumulants.tensor(hf,ha)\n\n# Define the operators\na = Destroy(hilb,:a)\nsm = Transition(hilb,:σ,:g,:e)\nsp = sm'\nsz = Transition(hilb,:σ,:e,:e)\n\n# Hamiltonian\nH = Δ*a'*a + g*(a'*sm + a*sp) + h*(a + a')\n\n# Coupling operators\nL = [κ*a]\n\nsys = SLH(:jc,[:In],[:Out],[1],L,H)\n###########################################################\nNcutoff = 10\nN_steps = 1000\nT = range(0,100,N_steps)\n\nparamrules = Dict([Δ=>0.1,\n                    g=>5.0,\n                    h=>0.1,\n                    κ=>0.3])\n\n\nqfi = compute_qfi(sys, Ncutoff,T, paramrules, h,AutoFiniteDiff())","category":"page"},{"location":"#SystemLevelHamiltonian","page":"Introduction","title":"SystemLevelHamiltonian","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A package for the design and analysis of open quantum systems.","category":"page"}]
}
