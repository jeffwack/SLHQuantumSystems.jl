var documenterSearchIndex = {"docs":
[{"location":"freqdepsqz/#Calculating-the-Hamiltonian-for-frequency-dependent-squeezing","page":"Calculating the Hamiltonian for frequency-dependent squeezing","title":"Calculating the Hamiltonian for frequency-dependent squeezing","text":"","category":"section"},{"location":"freqdepsqz/","page":"Calculating the Hamiltonian for frequency-dependent squeezing","title":"Calculating the Hamiltonian for frequency-dependent squeezing","text":"using SystemLevelHamiltonian\n\nfilter_cav = cavity(:filter)\nsqz_cav = squeezing_cavity(:sqz)\nifo = radiation_pressure_cavity(:ifo)\n\nsys = concatenate(:feqdepsqz,[sqz_cav,filter_cav,ifo])\nsys = feedbackreduce(sys,:Out_sqz,:In_filter)\nsys = feedbackreduce(sys,:Out_filter,:In_ifo)","category":"page"},{"location":"freqdepsqz/","page":"Calculating the Hamiltonian for frequency-dependent squeezing","title":"Calculating the Hamiltonian for frequency-dependent squeezing","text":"sys.H","category":"page"},{"location":"freqdepsqz/","page":"Calculating the Hamiltonian for frequency-dependent squeezing","title":"Calculating the Hamiltonian for frequency-dependent squeezing","text":"operators(sys)","category":"page"},{"location":"freqdepsqz/","page":"Calculating the Hamiltonian for frequency-dependent squeezing","title":"Calculating the Hamiltonian for frequency-dependent squeezing","text":"parameters(sys)","category":"page"},{"location":"api/#SLH-systems","page":"API","title":"SLH systems","text":"","category":"section"},{"location":"api/#SystemLevelHamiltonian.SLH","page":"API","title":"SystemLevelHamiltonian.SLH","text":"SLH(name, inputs, outputs, S, L, H)\n\nAn SLH triple describes an open quantum system. See Combes, arXiv.1611.00375\n\nThe name of the system should be unique. When multiple systems are combined, the names of their inputs and outputs will  have the system name appended to them. The inputs and outputs describe 'ports' where signals leave and enter the system. Quantum systems must have the same number of inputs and outputs, which we denote by n.\n\nsize(S) = (n, n) <- S is an nxn matrix size(L) = (n,) size(H) = ()\n\nThe two ways of combining SLH systems are concatenate() and feedbackreduce()\n\n\n\n\n\n","category":"type"},{"location":"api/#SystemLevelHamiltonian.concatenate","page":"API","title":"SystemLevelHamiltonian.concatenate","text":"concatenate(name, syslist::Vector{SLH})\n\ncreates a composite system with no interconnections. Combes eq. 59\n\n\n\n\n\n","category":"function"},{"location":"api/#SystemLevelHamiltonian.feedbackreduce","page":"API","title":"SystemLevelHamiltonian.feedbackreduce","text":"feedbackreduce(A::SLH,output,input)\n\nConnects the output port to the input port, reducing the number of outputs and inputs by one each. Combes eq 61.\n\n\n\n\n\n","category":"function"},{"location":"api/#SystemLevelHamiltonian.operators","page":"API","title":"SystemLevelHamiltonian.operators","text":"operators(sys)\n\nreturns all the quantum operators contained in the system's Hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"api/#SystemLevelHamiltonian.parameters","page":"API","title":"SystemLevelHamiltonian.parameters","text":"parameters(sys)\n\nreturns all the symbolic numbers contained in the system's Hamiltonian and coupling vector L.\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantum-information","page":"API","title":"Quantum information","text":"","category":"section"},{"location":"api/#SystemLevelHamiltonian.sld_operator","page":"API","title":"SystemLevelHamiltonian.sld_operator","text":"sld_operator(rho::AbstractMatrix, drho::AbstractMatrix; tol=1e-12)\n\nCompute the symmetric logarithmic derivative (SLD) L for a given density matrix rho and its parameter derivative drho, using the eigenbasis method. Returns L in the original basis.\n\nArguments\n\nrho: Hermitian density matrix (N×N)\ndrho: Derivative of the density matrix with respect to some parameter\ntol: Threshold for eigenvalues considered nonzero (default: 1e-5)\n\nReturns\n\nL: Symmetric logarithmic derivative (N×N Hermitian matrix)\n\n\n\n\n\n","category":"function"},{"location":"api/#SystemLevelHamiltonian.compute_qfi","page":"API","title":"SystemLevelHamiltonian.compute_qfi","text":"compute_qfi(sys,Ncutoff, T, params, param, backend)\n\nComputes the quantum Fisher information of the final state of the system after evolving for time T, with respect to the parameter 'param.' The nominal values of all parameters must be provided as a dictionary mapping parameters to values in 'params.' The differentiation required to calculate the symmetric logarithmic derivative is carried out by DifferentiationInterface, so an autodiff backend is passed as 'backend.' For now use AutoFiniteDiff(). \n\n\n\n\n\n","category":"function"},{"location":"ifoQC/#Linear-Interferometer-Readout-QuantumCumulants","page":"Linear Interferometer Readout - QuantumCumulants","title":"Linear Interferometer Readout - QuantumCumulants","text":"","category":"section"},{"location":"ifoQC/","page":"Linear Interferometer Readout - QuantumCumulants","title":"Linear Interferometer Readout - QuantumCumulants","text":"using QuantumCumulants","category":"page"},{"location":"ifoQC/","page":"Linear Interferometer Readout - QuantumCumulants","title":"Linear Interferometer Readout - QuantumCumulants","text":"hilb = FockSpace(:cavity)⊗FockSpace(:mirror)\n\na = Destroy(hilb,:a,1)\nb = Destroy(hilb,:b,2)\n\n@cnumbers Δ g κ \n\nH = Δ*b'*b + g*(a*b'+a'*b)\n\nL = [sqrt(κ)*a]\nnothing #hide","category":"page"},{"location":"ifoQC/","page":"Linear Interferometer Readout - QuantumCumulants","title":"Linear Interferometer Readout - QuantumCumulants","text":"ops = [a,a',b,b']\nheisenberg_eqs = meanfield(ops,H,L;rates=ones(size(L)),order=3)\n\nprint(string(heisenberg_eqs))","category":"page"},{"location":"ifoQC/","page":"Linear Interferometer Readout - QuantumCumulants","title":"Linear Interferometer Readout - QuantumCumulants","text":"c = CorrelationFunction(a', a, heisenberg_eqs)\n\neqs = complete(heisenberg_eqs)","category":"page"},{"location":"ifoQC/","page":"Linear Interferometer Readout - QuantumCumulants","title":"Linear Interferometer Readout - QuantumCumulants","text":"using ModelingToolkit\nusing OrdinaryDiffEq\n# Numerical solution\nps = (Δ, g, κ)\n@named sys = ODESystem(eqs)\nu0 = zeros(ComplexF64, length(eqs))\np0 = (1.0, 1.5, 0.25)\nprob = ODEProblem(sys,u0,(0.0,10.0),ps.=>p0)\nsol = solve(prob,RK4())","category":"page"},{"location":"ifoQT/#Linear-Quantum-System-QuantumToolbox","page":"Linear Quantum System - QuantumToolbox","title":"Linear Quantum System - QuantumToolbox","text":"","category":"section"},{"location":"ifoQT/","page":"Linear Quantum System - QuantumToolbox","title":"Linear Quantum System - QuantumToolbox","text":"using QuantumToolbox","category":"page"},{"location":"ifoQT/","page":"Linear Quantum System - QuantumToolbox","title":"Linear Quantum System - QuantumToolbox","text":"N = 4\na = destroy(N) ⊗ qeye(N)\nb = qeye(N) ⊗ destroy(N)\n\nH1 = QobjEvo(b'*b, (p,t)->p[1])\nH2 = QobjEvo(a'*b+a*b', (p,t)->p[2])\n\nH = H1+H2\n\nL = [QobjEvo(a, (p,t)->p[3])]\nnothing #hide","category":"page"},{"location":"ifoQT/","page":"Linear Quantum System - QuantumToolbox","title":"Linear Quantum System - QuantumToolbox","text":"tlist = LinRange(0, 100, 1000)\np0 = [0.01,500,10]\nψ0= basis(N,0) ⊗ basis(N,0)\n\neops = [a, a'*a,b,b'*b]\n\nsol = mesolve(H, ψ0, tlist, L;params = p0,e_ops=eops)\nnothing #hide","category":"page"},{"location":"ifoQT/","page":"Linear Quantum System - QuantumToolbox","title":"Linear Quantum System - QuantumToolbox","text":"using CairoMakie\n\nfig = Figure()\nax = Axis(fig[1,1])\n\nlines!(ax,tlist,real(sol.expect[2,:]),label = L\"$\\langle a' a \\rangle$\" )\nlines!(ax,tlist,real(sol.expect[4,:]),label = L\"$\\langle b' b \\rangle$\" )\naxislegend()\n\nfig","category":"page"},{"location":"ifoQT/","page":"Linear Quantum System - QuantumToolbox","title":"Linear Quantum System - QuantumToolbox","text":"corr = correlation_2op_1t(H,ψ0,tlist,L,a,a';params = p0)","category":"page"},{"location":"ifoQT/","page":"Linear Quantum System - QuantumToolbox","title":"Linear Quantum System - QuantumToolbox","text":"(omega, S) = spectrum_correlation_fft(tlist,corr)\n\nfig = Figure()\nax = Axis(fig[1,1],xscale = log10, yscale = log10)\nnz = Int(ceil(length(omega)/2+1))\n\nlines!(ax, omega[nz:end],S[nz:end])\n\nfig","category":"page"},{"location":"jcfisher/#Calculating-the-QFI-of-a-Jaynes-Cummings-model","page":"Calculating the QFI of a Jaynes-Cummings model","title":"Calculating the QFI of a Jaynes-Cummings model","text":"","category":"section"},{"location":"jcfisher/","page":"Calculating the QFI of a Jaynes-Cummings model","title":"Calculating the QFI of a Jaynes-Cummings model","text":"\nusing SystemLevelHamiltonian\nusing QuantumCumulants\nusing DifferentiationInterface\n\n##############################################################\n### SYSTEM DEFINITION\n\n# Define parameters and their numerical values\nps = @cnumbers Δ g κ h \n\n# Define hilbert space\nhf = FockSpace(:cavity)\nha = NLevelSpace(:atom,(:g,:e))\nhilb = QuantumCumulants.tensor(hf,ha)\n\n# Define the operators\na = Destroy(hilb,:a)\nsm = Transition(hilb,:σ,:g,:e)\nsp = sm'\nsz = Transition(hilb,:σ,:e,:e)\n\n# Hamiltonian\nH = Δ*a'*a + g*(a'*sm + a*sp) + h*(a + a')\n\n# Coupling operators\nL = [κ*a]\n\nsys = SLH(:jc,[:In],[:Out],[1],L,H)\n###########################################################\nNcutoff = 10\nN_steps = 1000\nT = range(0,100,N_steps)\n\nparamrules = Dict([Δ=>0.1,\n                    g=>5.0,\n                    h=>0.1,\n                    κ=>0.3])\n\n\nqfi = compute_qfi(sys, Ncutoff,T, paramrules, h,AutoFiniteDiff())","category":"page"},{"location":"cascadedoutputfilters/#Interferometer-readout","page":"General readout","title":"Interferometer readout","text":"","category":"section"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"We want to model a general interferometer readout protocol. We will model different temporal modes of the output signal by using a cascaded series of filters which collect light according to kappa_i(t), the `filter function.'","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"First, we will look at building the Hamiltonian of this cascaded system using the SLH formalism. For now we will model our nonlinear interferometer with the Jaynes-Cummings system. The package SystemLevelHamiltonian.jl implements the SLH composition rules, using the quantum algebra provided by the package QuantumCumulants.jl.","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"using SystemLevelHamiltonian \n\nifo = qed_cavity(:ifo)\n","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"Now we create our chain of filters","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"filters = [cavity(symb) for symb in [:A,:B]]","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"We use the SLH composition rules to assemble our system.","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"push!(filters,ifo)\nsys = concatenate(:sys,filters)\nsys = feedbackreduce(sys,:Out_ifo,:In_A)\nsys = feedbackreduce(sys,:Out_A,:In_B)","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"Even with two output filters, this Hamiltonian is a mess. It doesn't help that for now the symbolic system does not simplify or group terms nicely. We want to represent this Hamiltonian as a matrix to facilitate a density matrix calculation. Automating this procedure is WIP, so let's do something a bit manual to organize this Hamiltonian.","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"H_0 = Δ_A a_A^dagger a_A+Δ_B a_B^dagger a_B +g_ifo(a_ifo^dagger σ_ifo12 + a_ifo σ_ifo21)+Δ_ifo a_ifo^dagger a_ifo","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"H_1 = h_ifo (a_ifo + a_ifo^dagger)","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"H_2 = fraci2sqrtκ_A κ_ifo (a_A a_ifo^dagger -a_A^dagger a_ifo)","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"H_3 = fraci2sqrtκ_B κ_A(a_A^dagger a_B - a_A a_B^dagger)","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"H_4 = fraci2sqrtκ_B κ_ifo(a_B a_ifo^dagger - a_B^dagger a_ifo)","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"Now, we will build this system and simulate its time evolution using the package QuantumToolbox. We will send Delta_A and Delta_B to zero, as well as make the coupling rates kappa_A and kappa_B functions of time.","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"using QuantumToolbox","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"We first need to establish an order on the subspaces of our Hilbert space, as well as a cutoff for our Fock states.","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"textspin otimes textifo otimes textA otimes textB","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"N = 4\nσ  = sigmam() ⊗ qeye(N) ⊗ qeye(N) ⊗ qeye(N)\na_ifo = qeye(2) ⊗ destroy(N) ⊗ qeye(N) ⊗ qeye(N) \na_A = qeye(2) ⊗ qeye(N) ⊗ destroy(N) ⊗ qeye(N) \na_B = qeye(2) ⊗ qeye(N) ⊗ qeye(N) ⊗ destroy(N)\nnothing # hide","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"We can now define our constants and build the first part of the Hamiltonian","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"g = 2\nΔ = 0.5\n\nH_0 = Δ*a_ifo'*a_ifo + g*(a_ifo'*σ + a_ifo*σ')","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"We now define the first time dependent part","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"\n\n\nfunction signal(p,t)\n    return exp(-(t-p.d)^2/p.s^2)*p.A*sin(p.w*t)\nend\n\nH_1 = QobjEvo(a_ifo+a_ifo', signal)\nnothing # hide","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"kappaifo = 0.3\n\nfunction kappaA(p,t)\n    return Complex(exp(-(t-p.dA)^2/p.sA^2)*p.AA*sin(p.wA*t))\nend\n\nfunction kappaB(p,t)\n    return Complex(exp(-(t-p.dB)^2/p.sB^2)*p.AB*sin(p.wB*t))\nend\n\nfunction f2(p,t)\n    return 1.0im/2*sqrt(kappaA(p,t)*kappaifo)\nend\nH_2 = QobjEvo(a_A*a_ifo' - a_A'*a_ifo,f2)\n\nfunction f3(p,t)\n    return 1.0im/2*sqrt(kappaB(p,t)*kappaA(p,t))\nend\nH_3 = QobjEvo(a_A'*a_B - a_A*a_B',f3)\n\nfunction f4(p,t)\n    return 1.0im/2*sqrt(kappaB(p,t)*kappaifo)\nend\nH_4 = QobjEvo(a_B*a_ifo' - a_B'*a_ifo,f4)\n\nH_total = H_0 + H_1 + H_2 + H_3 + H_4","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"We now have the total Hamiltonian, which we can simulate by providing an initial state as well as parameters for all the time dependent functions.","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"ψ0 = basis(2,0) ⊗ fock(N, 0) ⊗ fock(N, 0) ⊗ fock(N, 0)\ntlist = 0:0.1:100 \n\np = (\n    d = 5, #center of signal pulse\n    s = 2, #width of signal pulse\n    A = 4, #amplitude of signal pulse\n    w = 3*2*pi, #frequency of signal pulse \n    dA = 3, #center \n    sA = 2, #width \n    AA = 2, #amplitude \n    wA = 2*2*pi, #frequency \n    dB = 8, #center \n    sB = 2, #width \n    AB = 2, #amplitude \n    wB = 4*2*pi #frequency \n)\n\nsol_me  = mesolve(H_total,  ψ0, tlist, params = p)","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"Now, we want to calculate the quantum Fisher information of the final state left in the filters with respect to the frequency of the signal (for example). To do this, we are going to wrap this solver call in a function which takes a frequency, time evolves, extracts the final state, and traces out the interferometer. This will then allow us to use the finite difference method to calculate the derivative with respect to a parameter and calculate the QFI.","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"function final_state(omega)\n    p = (\n        d = 5, #center of signal pulse\n        s = 2, #width of signal pulse\n        A = 4, #amplitude of signal pulse\n        w = omega, #frequency of signal pulse \n        dA = 3, #center \n        sA = 2, #width \n        AA = 2, #amplitude \n        wA = 2*2*pi, #frequency \n        dB = 8, #center \n        sB = 2, #width \n        AB = 2, #amplitude \n        wB = 4*2*pi #frequency \n    )\n\n    sol_me  = mesolve(H_total,  ψ0, tlist, params = p)\n    rho = ptrace(sol_me.states[end],(3,4))\n    return hermitian_data(rho)\nend\n\nfinal_state(3*2*pi)","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"\nfunction derivative(A,dA)\n    rho1 = final_state(A)\n    rho2 = final_state(A+dA)\n    \n    return (rho1, rho2, (rho2 - rho1)/dA)\nend\n\n(rho1, rho2, rhodot) = derivative(3*2*pi,0.001)\n\nL = sld_operator(rho1,rhodot)\n\nqfi = tr(L*L*rho1)\n","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"We can wrap all of this into a single function which will output the QFI of the system as a whole as well as each subsystem","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"function all_qfi(p,eps)\n\n    sol_me = mesolve(H_total,  ψ0, tlist, params = p)\n    rho_final = ket2dm(sol_me.states[end])\n\n    pp= merge(p,(w=p.w+eps,))\n    sol_me_prime = mesolve(H_total,  ψ0, tlist, params = pp)\n    rho_final_prime = ket2dm(sol_me_prime.states[end])\n\n    rho_dot_full = (hermitian_data(rho_final_prime) - hermitian_data(rho_final))/eps\n\n    L_full = sld_operator(hermitian_data(rho_final),rho_dot_full)\n    qfi_full = real(tr(L_full*L_full*hermitian_data(rho_final)))\n    println(\"qfi_full = $qfi_full\")\n\n    rho_ifo = ptrace(rho_final,(1,2))\n    rho_ifo_prime = ptrace(rho_final_prime,(1,2))\n    rho_dot_ifo = (hermitian_data(rho_ifo_prime) - hermitian_data(rho_ifo))/eps\n    L_ifo = sld_operator(hermitian_data(rho_ifo),rho_dot_ifo)\n    qfi_ifo = real(tr(L_ifo*L_ifo*hermitian_data(rho_ifo)))\n    println(\"qfi_ifo = $qfi_ifo\")\n\n    rho_filters = ptrace(rho_final,(3,4))\n    rho_filters_prime = ptrace(rho_final_prime,(3,4))\n    rho_dot_filters = (hermitian_data(rho_filters_prime) - hermitian_data(rho_filters))/eps\n    L_filters = sld_operator(hermitian_data(rho_filters),rho_dot_filters)\n    qfi_filters = real(tr(L_filters*L_filters*hermitian_data(rho_filters)))\n    println(\"qfi_filters = $qfi_filters\")\n\n    rho_A = ptrace(rho_final,3)\n    rho_A_prime = ptrace(rho_final_prime,3)\n    rho_dot_A = (hermitian_data(rho_A_prime) - hermitian_data(rho_A))/eps\n    L_A = sld_operator(hermitian_data(rho_A),rho_dot_A)\n    qfi_A = real(tr(L_A*L_A*hermitian_data(rho_A)))\n    println(\"qfi_A = $qfi_A\")\n\n    rho_B = ptrace(rho_final,4)\n    rho_B_prime = ptrace(rho_final_prime,4)\n    rho_dot_B = (hermitian_data(rho_B_prime) - hermitian_data(rho_B))/eps\n    L_B = sld_operator(hermitian_data(rho_B),rho_dot_B)\n    qfi_B = real(tr(L_B*L_B*hermitian_data(rho_B)))\n    println(\"qfi_B = $qfi_B\")\n\n\n    return\nend\n\neps = 0.0005\nnothing #hide","category":"page"},{"location":"cascadedoutputfilters/#Nominal-parameters","page":"General readout","title":"Nominal parameters","text":"","category":"section"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"p_nominal = (\n    d = 5, #center of signal pulse\n    s = 2, #width of signal pulse\n    A = 4, #amplitude of signal pulse\n    w = 3*2*pi, #frequency of signal pulse \n    dA = 3, #center \n    sA = 2, #width \n    AA = 2, #amplitude \n    wA = 2*2*pi, #frequency \n    dB = 8, #center \n    sB = 2, #width \n    AB = 2, #amplitude \n    wB = 4*2*pi #frequency \n    )\nall_qfi(p_nominal,eps)","category":"page"},{"location":"cascadedoutputfilters/#Sanity-check-second-filter-off","page":"General readout","title":"Sanity check - second filter off","text":"","category":"section"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"p = merge(p_nominal,(AB=0,))\nall_qfi(p,eps)","category":"page"},{"location":"cascadedoutputfilters/#sanity-check-late-signal","page":"General readout","title":"sanity check - late signal","text":"","category":"section"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"p = merge(p_nominal,(d=50,))\nall_qfi(p,eps)","category":"page"},{"location":"cascadedoutputfilters/#increase-signal-amplitude","page":"General readout","title":"increase signal amplitude","text":"","category":"section"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"p = merge(p_nominal,(A=p_nominal.A*4,))\nall_qfi(p,eps)","category":"page"},{"location":"#SystemLevelHamiltonian","page":"Introduction","title":"SystemLevelHamiltonian","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A package for the design and analysis of open quantum systems.","category":"page"},{"location":"oameyeQFI/#Quantum-Fisher-Information","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"","category":"section"},{"location":"oameyeQFI/#author:-Orjan-Ameye","page":"Quantum Fisher Information","title":"author: Orjan Ameye","text":"","category":"section"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"This notebook demonstrates the computation of Quantum Fisher Information (QFI) for a driven-dissipative Kerr Parametric Oscillator using automatic differentiation. The QFI quantifies the ultimate precision limit for parameter estimation in quantum systems.","category":"page"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"We import the necessary packages for quantum simulations and automatic differentiation:","category":"page"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"using QuantumToolbox      # Quantum optics simulations\nusing DifferentiationInterface  # Unified automatic differentiation interface\nusing SciMLSensitivity   # Allows for ODE sensitivity analysis\nusing FiniteDiff         # Finite difference methods\nusing LinearAlgebra      # Linear algebra operations\nusing CairoMakie              # Plotting","category":"page"},{"location":"oameyeQFI/#System-Parameters-and-Hamiltonian","page":"Quantum Fisher Information","title":"System Parameters and Hamiltonian","text":"","category":"section"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"The KPO system is governed by the Hamiltonian: H = -p_1 a^dagger a + K (a^dagger)^2 a^2 - G (a^dagger a^dagger + a a)","category":"page"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"where:","category":"page"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"p_1\nis the parameter we want to estimate (detuning)\nK\nis the Kerr nonlinearity\nG\nis the parametric drive strength\ngamma\nis the decay rate","category":"page"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"function final_state(p)\n    G, K, γ = 0.002, 0.001, 0.01\n\n    N = 20 # cutoff of the Hilbert space dimension\n    a = destroy(N) # annihilation operator\n\n    coef(p,t) = - p[1]\n    H = QobjEvo(a' * a , coef) + K * a' * a' * a * a - G * (a' * a' + a * a)\n    c_ops = [sqrt(γ)*a]\n    ψ0 = fock(N, 0) # initial state\n\n    tlist = range(0, 2000, 100)\n\n    sol = mesolve(H, ψ0, tlist, c_ops; params = p, progress_bar = Val(false), saveat = [tlist[end]])\n    return sol.states[end].data\nend","category":"page"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"function final_state(p, t)\n    G, K, γ = 0.002, 0.001, 0.01\n\n    N = 20 # cutoff of the Hilbert space dimension\n    a = destroy(N) # annihilation operator\n\n    coef(p,t) = - p[1]\n    H = QobjEvo(a' * a , coef) + K * a' * a' * a * a - G * (a' * a' + a * a)\n    c_ops = [sqrt(γ)*a]\n    ψ0 = fock(N, 0) # initial state\n\n    tlist = range(0, 2000, 100)\n\n    sol = mesolve(H, ψ0, tlist, c_ops; params = p, progress_bar = Val(false), saveat = [t])\n    return sol.states[end].data\nend","category":"page"},{"location":"oameyeQFI/#Quantum-Fisher-Information-Calculation","page":"Quantum Fisher Information","title":"Quantum Fisher Information Calculation","text":"","category":"section"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"The QFI is computed using the symmetric logarithmic derivative (SLD). For a density matrix rho(theta) parametrized by theta:","category":"page"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"F_Q = textTrpartial_theta rho cdot L","category":"page"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"where L is the SLD satisfying: partial_theta rho = frac12(rho L + L rho)","category":"page"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"function compute_fisher_information(ρ, dρ)\n    # Add small regularization to avoid numerical issues with zero eigenvalues\n    reg = 1e-12 * I\n    ρ_reg = ρ + reg\n\n    # Solve for the symmetric logarithmic derivative L\n    # dρ = (1/2)(ρL + Lρ)\n    # This is a Sylvester equation: ρL + Lρ = 2*dρ\n    L = sylvester(ρ_reg, ρ_reg, -2*dρ)\n\n    # Fisher information F = Tr(dρ * L)\n    F = real(tr(dρ * L))\n\n    return F\nend","category":"page"},{"location":"oameyeQFI/#Automatic-Differentiation-Setup","page":"Quantum Fisher Information","title":"Automatic Differentiation Setup","text":"","category":"section"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"We use finite differences through DifferentiationInterface.jl to compute the derivative of the quantum state with respect to the parameter. This is a key step that enables efficient QFI computation without manual derivative calculations.","category":"page"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"# Test the system\nfinal_state([0], 100)\n\n# Define state function for automatic differentiation\nstate(p) = final_state(p, 2000)\n\n# Compute both the state and its derivative\nρ, dρ = DifferentiationInterface.value_and_jacobian(state, AutoFiniteDiff(), [0.0])\n\n# Reshape the derivative back to matrix form\ndρ = QuantumToolbox.vec2mat(vec(dρ))\n\n# Compute QFI at final time\nqfi_final = compute_fisher_information(ρ, dρ)\nprintln(\"QFI at final time: \", qfi_final)","category":"page"},{"location":"oameyeQFI/#Time-Evolution-of-Quantum-Fisher-Information","page":"Quantum Fisher Information","title":"Time Evolution of Quantum Fisher Information","text":"","category":"section"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"Now we compute how the QFI evolves over time to understand the optimal measurement time for parameter estimation:","category":"page"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"ts = range(0, 2000, 100)\n\nQFI_t = map(ts) do t\n    state(p) = final_state(p, t)\n    ρ, dρ = DifferentiationInterface.value_and_jacobian(state, AutoFiniteDiff(), [0.0])\n    dρ = QuantumToolbox.vec2mat(vec(dρ))\n    compute_fisher_information(ρ, dρ)\nend\n\nprintln(\"QFI computed for \", length(ts), \" time points\")","category":"page"},{"location":"oameyeQFI/#Visualization","page":"Quantum Fisher Information","title":"Visualization","text":"","category":"section"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"Plot the time evolution of the Quantum Fisher Information:","category":"page"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"fig = Figure(size=(900, 350))\nax = Axis(\n fig[1,1],\n xlabel = \"Time\",\n ylabel = \"Quantum Fisher Information\"\n)\nlines!(ax, ts, QFI_t)\nfig","category":"page"},{"location":"oameyeQFI/#Version-Information","page":"Quantum Fisher Information","title":"Version Information","text":"","category":"section"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"QuantumToolbox.versioninfo()","category":"page"},{"location":"oameyeQFI/","page":"Quantum Fisher Information","title":"Quantum Fisher Information","text":"using Pkg\nPkg.status()","category":"page"}]
}
