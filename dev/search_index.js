var documenterSearchIndex = {"docs":
[{"location":"freqdepsqz/#Calculating-the-Hamiltonian-for-frequency-dependent-squeezing","page":"Calculating the Hamiltonian for frequency-dependent squeezing","title":"Calculating the Hamiltonian for frequency-dependent squeezing","text":"","category":"section"},{"location":"freqdepsqz/","page":"Calculating the Hamiltonian for frequency-dependent squeezing","title":"Calculating the Hamiltonian for frequency-dependent squeezing","text":"using SystemLevelHamiltonian\n\nfilter_cav = cavity(:filter)\nsqz_cav = squeezing_cavity(:sqz)\nifo = radiation_pressure_cavity(:ifo)\n\nsys = concatenate(:feqdepsqz,[sqz_cav,filter_cav,ifo])\nsys = feedbackreduce(sys,:Out_sqz,:In_filter)\nsys = feedbackreduce(sys,:Out_filter,:In_ifo)","category":"page"},{"location":"freqdepsqz/","page":"Calculating the Hamiltonian for frequency-dependent squeezing","title":"Calculating the Hamiltonian for frequency-dependent squeezing","text":"sys.H","category":"page"},{"location":"freqdepsqz/","page":"Calculating the Hamiltonian for frequency-dependent squeezing","title":"Calculating the Hamiltonian for frequency-dependent squeezing","text":"operators(sys)","category":"page"},{"location":"freqdepsqz/","page":"Calculating the Hamiltonian for frequency-dependent squeezing","title":"Calculating the Hamiltonian for frequency-dependent squeezing","text":"parameters(sys)","category":"page"},{"location":"api/#SLH-systems","page":"API","title":"SLH systems","text":"","category":"section"},{"location":"api/#SystemLevelHamiltonian.SLH","page":"API","title":"SystemLevelHamiltonian.SLH","text":"SLH(name, inputs, outputs, S, L, H)\n\nAn SLH triple describes an open quantum system. See Combes, arXiv.1611.00375\n\nThe name of the system should be unique. When multiple systems are combined, the names of their inputs and outputs will  have the system name appended to them. The inputs and outputs describe 'ports' where signals leave and enter the system. Quantum systems must have the same number of inputs and outputs, which we denote by n.\n\nsize(S) = (n, n) <- S is an nxn matrix size(L) = (n,) size(H) = ()\n\nThe two ways of combining SLH systems are concatenate() and feedbackreduce()\n\n\n\n\n\n","category":"type"},{"location":"api/#SystemLevelHamiltonian.concatenate","page":"API","title":"SystemLevelHamiltonian.concatenate","text":"concatenate(name, syslist::Vector{SLH})\n\ncreates a composite system with no interconnections. Combes eq. 59\n\n\n\n\n\n","category":"function"},{"location":"api/#SystemLevelHamiltonian.feedbackreduce","page":"API","title":"SystemLevelHamiltonian.feedbackreduce","text":"feedbackreduce(A::SLH,output,input)\n\nConnects the output port to the input port, reducing the number of outputs and inputs by one each. Combes eq 61.\n\n\n\n\n\n","category":"function"},{"location":"api/#SystemLevelHamiltonian.operators","page":"API","title":"SystemLevelHamiltonian.operators","text":"operators(sys)\n\nreturns all the quantum operators contained in the system's Hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"api/#SystemLevelHamiltonian.parameters","page":"API","title":"SystemLevelHamiltonian.parameters","text":"parameters(sys)\n\nreturns all the symbolic numbers contained in the system's Hamiltonian and coupling vector L.\n\n\n\n\n\n","category":"function"},{"location":"api/#Quantum-information","page":"API","title":"Quantum information","text":"","category":"section"},{"location":"api/#SystemLevelHamiltonian.sld_operator","page":"API","title":"SystemLevelHamiltonian.sld_operator","text":"sld_operator(rho::AbstractMatrix, drho::AbstractMatrix; tol=1e-12)\n\nCompute the symmetric logarithmic derivative (SLD) L for a given density matrix rho and its parameter derivative drho, using the eigenbasis method. Returns L in the original basis.\n\nArguments\n\nrho: Hermitian density matrix (N×N)\ndrho: Derivative of the density matrix with respect to some parameter\ntol: Threshold for eigenvalues considered nonzero (default: 1e-5)\n\nReturns\n\nL: Symmetric logarithmic derivative (N×N Hermitian matrix)\n\n\n\n\n\n","category":"function"},{"location":"api/#SystemLevelHamiltonian.compute_qfi","page":"API","title":"SystemLevelHamiltonian.compute_qfi","text":"compute_qfi(sys,Ncutoff, T, params, param, backend)\n\nComputes the quantum Fisher information of the final state of the system after evolving for time T, with respect to the parameter 'param.' The nominal values of all parameters must be provided as a dictionary mapping parameters to values in 'params.' The differentiation required to calculate the symmetric logarithmic derivative is carried out by DifferentiationInterface, so an autodiff backend is passed as 'backend.' For now use AutoFiniteDiff(). \n\n\n\n\n\n","category":"function"},{"location":"jcfisher/#Calculating-the-QFI-of-a-Jaynes-Cummings-model","page":"Calculating the QFI of a Jaynes-Cummings model","title":"Calculating the QFI of a Jaynes-Cummings model","text":"","category":"section"},{"location":"jcfisher/","page":"Calculating the QFI of a Jaynes-Cummings model","title":"Calculating the QFI of a Jaynes-Cummings model","text":"\nusing SystemLevelHamiltonian\nusing QuantumCumulants\nusing DifferentiationInterface\n\n##############################################################\n### SYSTEM DEFINITION\n\n# Define parameters and their numerical values\nps = @cnumbers Δ g κ h \n\n# Define hilbert space\nhf = FockSpace(:cavity)\nha = NLevelSpace(:atom,(:g,:e))\nhilb = QuantumCumulants.tensor(hf,ha)\n\n# Define the operators\na = Destroy(hilb,:a)\nsm = Transition(hilb,:σ,:g,:e)\nsp = sm'\nsz = Transition(hilb,:σ,:e,:e)\n\n# Hamiltonian\nH = Δ*a'*a + g*(a'*sm + a*sp) + h*(a + a')\n\n# Coupling operators\nL = [κ*a]\n\nsys = SLH(:jc,[:In],[:Out],[1],L,H)\n###########################################################\nNcutoff = 10\nN_steps = 1000\nT = range(0,100,N_steps)\n\nparamrules = Dict([Δ=>0.1,\n                    g=>5.0,\n                    h=>0.1,\n                    κ=>0.3])\n\n\nqfi = compute_qfi(sys, Ncutoff,T, paramrules, h,AutoFiniteDiff())","category":"page"},{"location":"cascadedoutputfilters/#Interferometer-readout","page":"General readout","title":"Interferometer readout","text":"","category":"section"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"We want to model a general interferometer readout protocol. We will model different temporal modes of the output signal by using a cascaded series of filters which collect light according to kappa_i(t), the `filter function.'","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"First, we will look at building the Hamiltonian of this cascaded system using the SLH formalism. For now we will model our nonlinear interferometer with the Jaynes-Cummings system. The package SystemLevelHamiltonian.jl implements the SLH composition rules, using the quantum algebra provided by the package QuantumCumulants.jl.","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"using SystemLevelHamiltonian \n\nifo = qed_cavity(:ifo)\n","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"Now we create our chain of filters","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"filters = [cavity(symb) for symb in [:A,:B]]","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"We use the SLH composition rules to assemble our system.","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"push!(filters,ifo)\nsys = concatenate(:sys,filters)\nsys = feedbackreduce(sys,:Out_ifo,:In_A)\nsys = feedbackreduce(sys,:Out_A,:In_B)","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"Even with two output filters, this Hamiltonian is a mess. It doesn't help that for now the symbolic system does not simplify or group terms nicely. We want to represent this Hamiltonian as a matrix to facilitate a density matrix calculation. Automating this procedure is WIP, so let's do something a bit manual to organize this Hamiltonian.","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"H_0 = Δ_A a_A^dagger a_A+Δ_B a_B^dagger a_B +g_ifo(a_ifo^dagger σ_ifo12 + a_ifo σ_ifo21)+Δ_ifo a_ifo^dagger a_ifo","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"H_1 = h_ifo (a_ifo + a_ifo^dagger)","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"H_2 = fraci2sqrtκ_A κ_ifo (a_A a_ifo^dagger -a_A^dagger a_ifo)","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"H_3 = fraci2sqrtκ_B κ_A(a_A^dagger a_B - a_A a_B^dagger)","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"H_4 = fraci2sqrtκ_B κ_ifo(a_B a_ifo^dagger - a_B^dagger a_ifo)","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"Now, we will build this system and simulate its time evolution using the package QuantumToolbox. We will send Delta_A and Delta_B to zero, as well as make the coupling rates kappa_A and kappa_B functions of time.","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"using QuantumToolbox","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"We first need to establish an order on the subspaces of our Hilbert space, as well as a cutoff for our Fock states.","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"textspin otimes textifo otimes textA otimes textB","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"N = 4\nσ  = sigmam() ⊗ qeye(N) ⊗ qeye(N) ⊗ qeye(N)\na_ifo = qeye(2) ⊗ destroy(N) ⊗ qeye(N) ⊗ qeye(N) \na_A = qeye(2) ⊗ qeye(N) ⊗ destroy(N) ⊗ qeye(N) \na_B = qeye(2) ⊗ qeye(N) ⊗ qeye(N) ⊗ destroy(N)\nnothing # hide","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"We can now define our constants and build the first part of the Hamiltonian","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"g = 2\nΔ = 0.5\n\nH_0 = Δ*a_ifo'*a_ifo + g*(a_ifo'*σ + a_ifo*σ')","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"We now define the first time dependent part","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"\n\n\nfunction signal(p,t)\n    return exp(-(t-p.d)^2/p.s^2)*p.A*sin(p.w*t)\nend\n\nH_1 = QobjEvo(a_ifo+a_ifo', signal)\nnothing # hide","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"kappaifo = 0.3\n\nfunction kappaA(p,t)\n    return Complex(exp(-(t-p.dA)^2/p.sA^2)*p.AA*sin(p.wA*t))\nend\n\nfunction kappaB(p,t)\n    return Complex(exp(-(t-p.dB)^2/p.sB^2)*p.AB*sin(p.wB*t))\nend\n\nfunction f2(p,t)\n    return 1.0im/2*sqrt(kappaA(p,t)*kappaifo)\nend\nH_2 = QobjEvo(a_A*a_ifo' - a_A'*a_ifo,f2)\n\nfunction f3(p,t)\n    return 1.0im/2*sqrt(kappaB(p,t)*kappaA(p,t))\nend\nH_3 = QobjEvo(a_A'*a_B - a_A*a_B',f3)\n\nfunction f4(p,t)\n    return 1.0im/2*sqrt(kappaB(p,t)*kappaifo)\nend\nH_4 = QobjEvo(a_B*a_ifo' - a_B'*a_ifo,f4)\n\nH_total = H_0 + H_1 + H_2 + H_3 + H_4","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"We now have the total Hamiltonian, which we can simulate by providing an initial state as well as parameters for all the time dependent functions.","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"ψ0 = basis(2,0) ⊗ fock(N, 0) ⊗ fock(N, 0) ⊗ fock(N, 0)\ntlist = 0:0.1:100 \n\np = (\n    d = 5, #center of signal pulse\n    s = 2, #width of signal pulse\n    A = 4, #amplitude of signal pulse\n    w = 3*2*pi, #frequency of signal pulse \n    dA = 3, #center \n    sA = 2, #width \n    AA = 2, #amplitude \n    wA = 2*2*pi, #frequency \n    dB = 8, #center \n    sB = 2, #width \n    AB = 2, #amplitude \n    wB = 4*2*pi #frequency \n)\n\nsol_me  = mesolve(H_total,  ψ0, tlist, params = p)","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"Now, we want to calculate the quantum Fisher information of the final state left in the filters with respect to the frequency of the signal (for example). To do this, we are going to wrap this solver call in a function which takes a frequency, time evolves, extracts the final state, and traces out the interferometer. This will then allow us to use the finite difference method to calculate the derivative with respect to a parameter and calculate the QFI.","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"function final_state(omega)\n    p = (\n        d = 5, #center of signal pulse\n        s = 2, #width of signal pulse\n        A = 4, #amplitude of signal pulse\n        w = omega, #frequency of signal pulse \n        dA = 3, #center \n        sA = 2, #width \n        AA = 2, #amplitude \n        wA = 2*2*pi, #frequency \n        dB = 8, #center \n        sB = 2, #width \n        AB = 2, #amplitude \n        wB = 4*2*pi #frequency \n    )\n\n    sol_me  = mesolve(H_total,  ψ0, tlist, params = p)\n    rho = ptrace(sol_me.states[end],(3,4))\n    return hermitian_data(rho)\nend\n\nfinal_state(3*2*pi)","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"\nfunction derivative(A,dA)\n    rho1 = final_state(A)\n    rho2 = final_state(A+dA)\n    \n    return (rho1, rho2, (rho2 - rho1)/dA)\nend\n\n(rho1, rho2, rhodot) = derivative(3*2*pi,0.001)\n\nL = sld_operator(rho1,rhodot)\n\nqfi = tr(L*L*rho1)\n","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"We can wrap all of this into a single function which will output the QFI of the system as a whole as well as each subsystem","category":"page"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"function all_qfi(p,eps)\n\n    sol_me = mesolve(H_total,  ψ0, tlist, params = p)\n    rho_final = ket2dm(sol_me.states[end])\n\n    pp= merge(p,(w=p.w+eps,))\n    sol_me_prime = mesolve(H_total,  ψ0, tlist, params = pp)\n    rho_final_prime = ket2dm(sol_me_prime.states[end])\n\n    rho_dot_full = (hermitian_data(rho_final_prime) - hermitian_data(rho_final))/eps\n\n    L_full = sld_operator(hermitian_data(rho_final),rho_dot_full)\n    qfi_full = real(tr(L_full*L_full*hermitian_data(rho_final)))\n    println(\"qfi_full = $qfi_full\")\n\n    rho_ifo = ptrace(rho_final,(1,2))\n    rho_ifo_prime = ptrace(rho_final_prime,(1,2))\n    rho_dot_ifo = (hermitian_data(rho_ifo_prime) - hermitian_data(rho_ifo))/eps\n    L_ifo = sld_operator(hermitian_data(rho_ifo),rho_dot_ifo)\n    qfi_ifo = real(tr(L_ifo*L_ifo*hermitian_data(rho_ifo)))\n    println(\"qfi_ifo = $qfi_ifo\")\n\n    rho_filters = ptrace(rho_final,(3,4))\n    rho_filters_prime = ptrace(rho_final_prime,(3,4))\n    rho_dot_filters = (hermitian_data(rho_filters_prime) - hermitian_data(rho_filters))/eps\n    L_filters = sld_operator(hermitian_data(rho_filters),rho_dot_filters)\n    qfi_filters = real(tr(L_filters*L_filters*hermitian_data(rho_filters)))\n    println(\"qfi_filters = $qfi_filters\")\n\n    rho_A = ptrace(rho_final,3)\n    rho_A_prime = ptrace(rho_final_prime,3)\n    rho_dot_A = (hermitian_data(rho_A_prime) - hermitian_data(rho_A))/eps\n    L_A = sld_operator(hermitian_data(rho_A),rho_dot_A)\n    qfi_A = real(tr(L_A*L_A*hermitian_data(rho_A)))\n    println(\"qfi_A = $qfi_A\")\n\n    rho_B = ptrace(rho_final,4)\n    rho_B_prime = ptrace(rho_final_prime,4)\n    rho_dot_B = (hermitian_data(rho_B_prime) - hermitian_data(rho_B))/eps\n    L_B = sld_operator(hermitian_data(rho_B),rho_dot_B)\n    qfi_B = real(tr(L_B*L_B*hermitian_data(rho_B)))\n    println(\"qfi_B = $qfi_B\")\n\n\n    return\nend\n\neps = 0.0005\nnothing #hide","category":"page"},{"location":"cascadedoutputfilters/#Nominal-parameters","page":"General readout","title":"Nominal parameters","text":"","category":"section"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"p_nominal = (\n    d = 5, #center of signal pulse\n    s = 2, #width of signal pulse\n    A = 4, #amplitude of signal pulse\n    w = 3*2*pi, #frequency of signal pulse \n    dA = 3, #center \n    sA = 2, #width \n    AA = 2, #amplitude \n    wA = 2*2*pi, #frequency \n    dB = 8, #center \n    sB = 2, #width \n    AB = 2, #amplitude \n    wB = 4*2*pi #frequency \n    )\nall_qfi(p_nominal,eps)","category":"page"},{"location":"cascadedoutputfilters/#Sanity-check-second-filter-off","page":"General readout","title":"Sanity check - second filter off","text":"","category":"section"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"p = merge(p_nominal,(AB=0,))\nall_qfi(p,eps)","category":"page"},{"location":"cascadedoutputfilters/#sanity-check-late-signal","page":"General readout","title":"sanity check - late signal","text":"","category":"section"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"p = merge(p_nominal,(d=50,))\nall_qfi(p,eps)","category":"page"},{"location":"cascadedoutputfilters/#increase-signal-amplitude","page":"General readout","title":"increase signal amplitude","text":"","category":"section"},{"location":"cascadedoutputfilters/","page":"General readout","title":"General readout","text":"p = merge(p_nominal,(A=p_nominal.A*4,))\nall_qfi(p,eps)","category":"page"},{"location":"#SystemLevelHamiltonian","page":"Introduction","title":"SystemLevelHamiltonian","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A package for the design and analysis of open quantum systems.","category":"page"}]
}
