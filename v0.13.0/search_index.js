var documenterSearchIndex = {"docs":
[{"location":"generated/freqdepsqz/","page":"Freqdepsqz","title":"Freqdepsqz","text":"using SLHQuantumSystems\n\nSQZ = squeezing_cavity(\"A\")\nFCV = cavity(\"B\")\n\nSYS = concatenate([SQZ,FCV],\"sys\")\nSYS = feedbackreduce(SYS,\"A_out\",\"B_in\")\n\nSS = StateSpace(SYS)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/#SLH-type","page":"API","title":"SLH type","text":"","category":"section"},{"location":"api/#SLH-Operations","page":"API","title":"SLH Operations","text":"","category":"section"},{"location":"api/#Conversion","page":"API","title":"Conversion","text":"","category":"section"},{"location":"api/#Symbolic-Utilities","page":"API","title":"Symbolic Utilities","text":"","category":"section"},{"location":"api/#Component-Library","page":"API","title":"Component Library","text":"","category":"section"},{"location":"api/#Function-Index","page":"API","title":"Function Index","text":"","category":"section"},{"location":"api/#SLHQuantumSystems.SLH","page":"API","title":"SLHQuantumSystems.SLH","text":"SLH(name, inputs, outputs, S, L, H)\n\nAn SLH triple describes an open quantum system. See Combes, arXiv.1611.00375\n\nThe name of the system should be unique. When multiple systems are combined, the names of their inputs and outputs will  have the system name appended to them. The inputs and outputs describe 'ports' where signals leave and enter the system. Quantum systems must have the same number of inputs and outputs, which we denote by n.\n\nsize(S) = (n, n) <- S is an nxn matrix\n\nsize(L) = (n,)\n\nsize(H) = ()\n\nThe two ways of combining SLH systems are concatenate() and feedbackreduce()\n\n\n\n\n\n","category":"type"},{"location":"api/#SLHQuantumSystems.concatenate","page":"API","title":"SLHQuantumSystems.concatenate","text":"concatenate(name, syslist::Vector{SLH})\n\ncreates a composite system with no interconnections. Combes eq. 59\n\nWhen systems are concatenated, the names of their inputs, outputs, operators, parameters, and Hilbert spaces are 'promoted' by prepending the name of the  system to the existing name. This prevents name collisions as long as all  SLHSystems are created with a unique name.\n\n\n\n\n\n","category":"function"},{"location":"api/#SLHQuantumSystems.feedbackreduce","page":"API","title":"SLHQuantumSystems.feedbackreduce","text":"feedbackreduce(A::SLH,output,input)\n\nConnects the output port to the input port, reducing the number of outputs and inputs by one each. Combes eq 61.\n\n\n\n\n\n","category":"function"},{"location":"api/#SLHQuantumSystems.operators","page":"API","title":"SLHQuantumSystems.operators","text":"operators(sys)\n\nreturns all the quantum operators contained in the system's Hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"api/#SLHQuantumSystems.parameters","page":"API","title":"SLHQuantumSystems.parameters","text":"parameters(sys)\n\nreturns all the symbolic numbers contained in the system's Hamiltonian and coupling vector L.\n\n\n\n\n\n","category":"function"},{"location":"api/#SLHQuantumSystems.slh2abcd","page":"API","title":"SLHQuantumSystems.slh2abcd","text":"slh2abcd(sys::SLH)\n\nConvert a linear quantum system from SLH representation to ABCD representation.\n\nThe name of the new system, as well as the names of its imputs and outputs will be directly inherited from the input system.\n\n\n\n\n\n","category":"function"},{"location":"api/#SLHQuantumSystems.get_qnumbers","page":"API","title":"SLHQuantumSystems.get_qnumbers","text":"get_qnumbers(expr)\n\nExtract all quantum operators from an expression.\n\nArguments\n\nexpr: A symbolic expression\n\nReturns\n\nSet: Set of quantum operators found in the expression\n\n\n\n\n\n","category":"function"},{"location":"api/#SLHQuantumSystems.get_cnumbers","page":"API","title":"SLHQuantumSystems.get_cnumbers","text":"get_numsymbols(expr)\n\nExtract all symbolic parameters from an expression.\n\nArguments\n\nexpr: A symbolic expression\n\nReturns\n\nSet: Set of symbolic parameters found in the expression\n\n\n\n\n\n","category":"function"},{"location":"api/#SLHQuantumSystems.get_additive_terms","page":"API","title":"SLHQuantumSystems.get_additive_terms","text":"get_additive_terms(expr)\n\nExtract additive terms from a quantum operator expression.\n\nTakes an expression containing quantum operators and returns a list of terms that contain no addition, only multiplication. Summing all returned terms results in the original expression.\n\nArguments\n\nexpr: A symbolic expression containing quantum operators\n\nReturns\n\nVector: List of terms without addition operators\n\n\n\n\n\n","category":"function"},{"location":"api/#SLHQuantumSystems.cavity","page":"API","title":"SLHQuantumSystems.cavity","text":"cavity(name)\n\nCreate a basic optical cavity SLH system.\n\nCreates a single-mode cavity with detuning and decay. The cavity has one input  and one output port with direct transmission (S=1).\n\nArguments\n\nname: Symbol identifying the cavity (used for operator and parameter naming)\n\nReturns\n\nSLH: System with Hamiltonian H = Δ·a†a and coupling L = [κa]\n\nParameters\n\nκ: Cavity decay rate\nΔ: Cavity detuning from driving field\n\n\n\n\n\n","category":"function"},{"location":"api/#SLHQuantumSystems.squeezing_cavity","page":"API","title":"SLHQuantumSystems.squeezing_cavity","text":"squeezing_cavity(name)\n\nCreate a squeezing cavity SLH system.\n\nCreates a cavity that generates squeezed light through a parametric  interaction (two-mode squeezing Hamiltonian).\n\nArguments\n\nname: Symbol identifying the cavity (used for operator and parameter naming)\n\nReturns\n\nSLH: System with squeezing Hamiltonian H = iϵ(a†² - a²) and coupling L = [√κ·a]\n\nParameters\n\nκ: Cavity decay rate\nϵ: Squeezing strength \n\n\n\n\n\n","category":"function"},{"location":"LinearQuantumNetworks/#Linear-Quantum-Networks","page":"Linear quantum networks","title":"Linear Quantum Networks","text":"Linear quantum systems are open quantum systems that consist of harmonic bosonic modes with quadratic Hamiltonians and linear couplings to external fields. They are extensively studied in quantum optics, where they can describe systems of optical resonators, beamsplitters, and quadratic optical nonlinearity such as two-mode squeezing.","category":"section"},{"location":"LinearQuantumNetworks/#ABCD-(state-space)","page":"Linear quantum networks","title":"ABCD (state space)","text":"The 'state' of a linear system in the Heisenberg picture is specified by the time evolved creation and annihilation operators for every mode, which we can collect into the 'state vector' of the system.\n\nbolda(t) = \nbeginbmatrix \na_1(t) \na^dagger_1(t) \nvdots \na_m(t) \na^dagger_m(t)\nendbmatrix\n\nThis allows us to write the Heisenberg equations of motion for a linear system in vector form,\n\ndotbolda(t) =\ni Hbolda(t) = Abolda(t)\n\nfor some matrix A.\n\nTo include inputs and outputs we introduce vectors of 'bath modes,' bolda_in(t) and bolda_out(t).\n\nNow, the full equations of motion can be written as\n\nbeginalign*\ndotbolda(t) = Abolda(t) + Bbolda_in(t) \nbolda_out(t) = Cbolda(t) + Dbolda_in(t)\nendalign*","category":"section"},{"location":"LinearQuantumNetworks/#Quadrature-Operator-Basis","page":"Linear quantum networks","title":"Quadrature Operator Basis","text":"","category":"section"},{"location":"LinearQuantumNetworks/#Optical-Modes","page":"Linear quantum networks","title":"Optical Modes","text":"We can also represent the state of the system using quadrature operators, defined by the relations:\n\nx = frac1sqrt2(a^dagger + a)\nquad quad\np = fracisqrt2(a^dagger - a)\n\nnote that for a single mode,\n\nbeginbmatrix\nx  p\nendbmatrix\n= \nfrac1sqrt2\nbeginpmatrix\n1  1\n-i  i\nendpmatrix\nbeginbmatrix\na  a^dagger\nendbmatrix\n\ngiving the vector relationship\n\nboldx(t) = \nbeginbmatrix\nx_1(t) \np_1(t) \nvdots \nx_m(t) \np_m(t)\nendbmatrix\n=\nfrac1sqrt2\nbeginpmatrix\n1  1  cdots  0  0 \ni  -i  cdots  0  0 \nvdots  vdots  ddots  vdots  vdots \n0  0  cdots  1  1 \n0  0  cdots  i  -i\nendpmatrix\nbeginbmatrix\na_1(t) \na^dagger_1(t) \nvdots \na_m(t) \na^dagger_m(t)\nendbmatrix\n= T_m bolda(t) \n\nWhere T_m = I_m otimes T and we have defined T to be the single mode transformation matrix.\n\nThe full equations of motion in the quadrature basis are\n\nbeginalign*\ndotboldx(t) = Aboldx(t) + Bboldu(t) \nboldy(t) = Cboldx(t) + Dboldu(t)\nendalign*","category":"section"},{"location":"LinearQuantumNetworks/#Mechanical-Modes","page":"Linear quantum networks","title":"Mechanical Modes","text":"The operators x and p have different units for mechanical systems compared to optical quadratures, and thus the transformation from annihilation and creation operators to quadratures takes a slightly different form.\n\nbeginbmatrix\nx  p\nendbmatrix\n=\nfrac1sqrt2momega\nbeginpmatrix\n1  1 \n-i m omega  i m omega\nendpmatrix\nbeginbmatrix\na  a^dagger\nendbmatrix","category":"section"},{"location":"LinearQuantumNetworks/#Named-Inputs-and-Outputs","page":"Linear quantum networks","title":"Named Inputs and Outputs","text":"Our SLH systems have named input and output ports. When dealing with linear systems, we double the number of inputs and outputs by considering annihilation and creation operators or both quadratures separately. When specifying a single quadrature, use the syntax [:in][1]. ","category":"section"},{"location":"generated/cascadedcavities/","page":"Cascadedcavities","title":"Cascadedcavities","text":"using SLHQuantumSystems\n\ncavA = cavity(\"A\")\ncavB = cavity(\"B\")\n\nsys = concatenate([cavA,cavB],\"sys\")\n\nsys = feedbackreduce(sys,\"B_out\",\"A_in\")\n\nprintln(sys.parameters) println(sys.operators) println(sys.H)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"literate-workflow/#Literate.jl-Workflow","page":"Literate Workflow","title":"Literate.jl Workflow","text":"This documentation uses Literate.jl to automatically generate documentation pages from executable Julia scripts. This approach ensures that a single file can be executed directly while also serving as formatted documentation with explanations.","category":"section"},{"location":"literate-workflow/#How-It-Works-Script-Discovery-and-Generation","page":"Literate Workflow","title":"How It Works - Script Discovery and Generation","text":"When the documentation is built, the following process occurs:\n\nAuto-discovery: The build system scans examples/ for all .jl files using walkdir()\nConversion: Each script is processed by Literate.jl to generate markdown in docs/src/generated/\nIntegration: Generated markdown files are automatically added to the documentation via GENERATED_EXAMPLE_PAGES","category":"section"},{"location":"literate-workflow/#Development-with-LiveServer","page":"Literate Workflow","title":"Development with LiveServer","text":"For live development, use LiveServer with proper configuration to avoid double triggers:\n\nusing LiveServer\nservedocs(literate_dir=\"examples\", skip_dir=\"docs/src/generated\")\n\nThis setup:\n\nWatches source files for changes and rebuilds docs automatically\nUses literate_dir=\"examples\" to tell LiveServer where the Literate scripts are\nUses skip_dir=\"docs/src/generated\" to prevent watching generated files (avoids infinite loops)","category":"section"},{"location":"literate-workflow/#Writing-Literate-Scripts","page":"Literate Workflow","title":"Writing Literate Scripts","text":"Literate.jl uses a simple convention for mixing code and documentation:\n\nDocumentation: Lines starting with # (with a space) become markdown\nCode: Regular Julia code becomes executable code blocks\nHeaders: Use # # Header for markdown headers (note the extra #)\n\nSee the Literate.jl docs for more information.","category":"section"},{"location":"literate-workflow/#File-Organization","page":"Literate Workflow","title":"File Organization","text":"SLHQuantumSystems.jl/\n├── examples/                    # Literate scripts (input)\n│   ├── cascadedcavities.jl     \n│   ├── cavityfeedback.jl       \n│   └── fabry_perot.jl          # Automatically discovered\n├── docs/\n│   ├── src/\n│   │   ├── generated/          # Auto-generated markdown (don't edit!)\n│   │   │   ├── cascadedcavities.md\n│   │   │   ├── cavityfeedback.md\n│   │   │   └── fabry_perot.md\n│   │   ├── index.md\n│   │   └── api.md\n│   ├── generate.jl             # Literate processing script\n│   └── make.jl                 # Documenter build script","category":"section"},{"location":"literate-workflow/#Build-Process","page":"Literate Workflow","title":"Build Process","text":"The workflow follows the official LiveServer + Literate.jl pattern:\n\ngenerate.jl: Uses walkdir() to discover all .jl files in examples/\nLiterate.markdown(): Converts each script to markdown with documenter=true, execute=false\nmake.jl: Includes generate.jl, then runs makedocs() with dynamically generated pages\nLiveServer: Watches files but skips the generated directory to prevent double builds","category":"section"},{"location":"literate-workflow/#Adding-New-Examples","page":"Literate Workflow","title":"Adding New Examples","text":"To add a new example to the documentation:\n\nCreate the script: Add a new .jl file to the examples/ directory\nUse Literate format: Write using the comment conventions above\n\nNo manual configuration is needed! The system automatically:\n\nDiscovers the new file\nConverts it to markdown\nAdds it to the documentation navigation\nCreates a properly formatted title from the filename","category":"section"},{"location":"literate-workflow/#Manual-Testing","page":"Literate Workflow","title":"Manual Testing","text":"You can test individual examples by running them directly:\n\njulia> include(\"examples/cascadedcavities.jl\")\n\nThis ensures that your examples actually work before they become documentation.","category":"section"},{"location":"generated/fabry_perot/","page":"Fabry_Perot","title":"Fabry_Perot","text":"using SecondQuantizedAlgebra\nusing SLHQuantumSystems\nusing Symbolics\nusing GLMakie\n\nhilb = FockSpace(:cav)\na = Destroy(hilb, :a)\n\n@cnumbers ω κ_L κ_R\n\ncav = SLH(\"cav\",[1 0; 0 1],[√κ_L*a, √κ_R*a],ω*a'*a)\n\ncavSS = StateSpace(cav)\n\nquadcavSS = toquadrature(cavSS)\n\n#aasymbtfs = symbfresponse(cavSS)\n#quadsymbtfs = symbfresponse(quadcavSS)\n\nparamdict = Dict([ω => 10, κ_L => 3, κ_R => 2])\n\nnumcav = substitute(cavSS,paramdict)\n\nnumcavquad = toquadrature(numcav)\n\nbode(numcavquad,(\"in1\",1),(\"out2\",1),collect(logrange(1,10000,100)))\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/optomechanical/","page":"Optomechanical","title":"Optomechanical","text":"using SLHQuantumSystems\nusing SecondQuantizedAlgebra\nusing Symbolics\nusing GLMakie\n\n#following 1.5.4 in Linear Dynamical Quantum Systems we will build the Hamiltonian in the quadrature basis hilb = PhaseSpace(:light) ⊗ PhaseSpace(:mirror)\n\nq1 = Position(hilb,:q1,1) q2 = Momentum(hilb,:q2,1) x = Position(hilb,:x,2) p = Momentum(hilb,:p,2)\n\n@rnumbers m ω g κ\n\nH = mω^2x^2/2 + p^2/(2m) + gxq1 L = κ(q1+1.0im*q2) S = [1]\n\noptomech = SLH(:opto, [:in], [:out], S, L, H) #gives error: Hilbert space has non-bosinic modes.\n\nWe construct the Hamiltonian using creation and annihilation operators\n\nhilb = FockSpace(:cavity)⊗FockSpace(:mirror)\n\nsubspaces = [OpticalMode(\"\"),MechanicalMode(\"\")]\n\na = Destroy(hilb,operatornames(subspaces[1])[1],1)\nb = Destroy(hilb,operatornames(subspaces[2])[1],2)\n\n(ω,l,κ) = rnumbers(parameternames(subspaces[1])...)\n(Ω,m,Γ) = rnumbers(parameternames(subspaces[2])...)\n\ng = rnumbers(:g)[1]#coupling parameter is defined separately\n\n#Hamiltonian (Chen 2013 eq 2.4)\nH = Ω*b'*b - g*(b'+b)*(a' + a)\nL = [κ*a,Γ*b]\nS = [1 0; 0 1]\n\nparams = [ω,l,κ,Ω,m,Γ,g]\npdict = Dict(zip(nameof.(params),params))\nslh = SLH(\"opto\",subspaces,pdict,[\"l_in\",\"m_in\"],[\"l_out\",\"m_out\"], S, L, H)\naass = StateSpace(slh)\nqss = toquadrature(aass)\n\n#Now we want to substitute numerical values.\n\nparamdict = Dict([ω => 0, l=>1, κ => sqrt(2*2*pi*100),Ω=>0.1,m=> 1000,g=>1000,Γ => 0.001])\n\nnumeric = substitute(qss,paramdict)\n\nfreq = collect(logrange(0.01,10000,1000))\n\nN = fresponse_allIO(numeric,freq)\nS = fresponse_state2output(numeric, freq, 1,2)\n\nfig = Figure()\nax = Axis(fig[1,1],xscale=log10, yscale=log10)\nscatter!(ax,freq,abs.(N[2,2]);label=\"2,2\")\nscatter!(ax,freq,abs.(N[2,1]);label=\"2,1\")\nscatter!(ax,freq,abs.(N[2,1]-N[2,2]);label=\"sum\")\nscatter!(ax,freq,abs.(S);label=\"signal\")\naxislegend(ax)\nfig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/mechanical/","page":"Mechanical","title":"Mechanical","text":"using SLHQuantumSystems\nusing SecondQuantizedAlgebra\nusing Symbolics\n\nmode = MechanicalMode(\"\")\n\n(Ω, m,  Γ) = rnumbers(parameternames(mode)...)\nb = Destroy(FockSpace(:mass),operatornames(mode)[1])\nparamdict = Dict(zip(nameof.([Ω,m,Γ]),[Ω,m,Γ]))\nslh = SLH(\"mass\",[mode],paramdict,[\"in\"],[\"out\"],[1],[Γ*b],Ω*b'*b)\n\nss = StateSpace(slh)\nqss = toquadrature(ss)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#SLHQuantumSystems.jl","page":"Home","title":"SLHQuantumSystems.jl","text":"SLHQuantumSystems.jl is a Julia package for creating and composing open quantum systems using the SLH framework. ","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"Get started by running one of the examples!\n\ninclude(\"examples/cascadedcavities.jl\")","category":"section"},{"location":"#Overview-of-SLH-systems","page":"Home","title":"Overview of SLH systems","text":"The SLH framework represents each open quantum systems with three components:\n\nS: Scattering matrix describing direct input-output coupling of external (bath) modes\nL: Coupling vector describing the interaction of the internal modes with the external modes \nH: System Hamiltonian describing internal dynamics","category":"section"},{"location":"#Component-Library","page":"Home","title":"Component Library","text":"The SLH framework enables you to create complicated quantum systems by combining simple, reusable components\n\nPre-built quantum components including:\nBasic cavities\nSqueezing cavities  \nRadiation pressure cavities\nJaynes-Cummings QED cavity","category":"section"},{"location":"#Dependencies","page":"Home","title":"Dependencies","text":"SecondQuantizedAlgebra.jl provides the symbolic algebra system for quantum operators","category":"section"},{"location":"#References","page":"Home","title":"References","text":"This package was inspired by QNET, a python package for working with SLH systems.\nThe SLH framework for modeling quantum input-output networks [1]\n\nJ. Combes, J. Kerckhoff and M. Sarovar. The SLH framework for modeling quantum input-output networks. Advances in Physics: X 2, 784–888 (2017), arXiv:1611.00375 [quant-ph].\n\n\n\n","category":"section"}]
}
